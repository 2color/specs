# Binaries

<!-- toc -->

- [Motivation](#motivation)
- [Requirements](#requirements)
- [Configuration API](#configuration-api)
- [Basic Example](#basic-example)
- [Scenarios](#scenarios)
  - [1. Development machine is Mac but the deployment platform is AWS lambda.](#1-development-machine-is-mac-but-the-deployment-platform-is-aws-lambda)
  - [2. Deterministically choose the binary-based a runtime environment variable](#2-deterministically-choose-the-binary-based-a-runtime-environment-variable)
  - [3. Development machine is Mac but we need a custom binary in production](#3-development-machine-is-mac-but-we-need-a-custom-binary-in-production)
  - [4. Development machine is a Raspberry Pi and the deployment platform is AWS Lambda](#4-development-machine-is-a-raspberry-pi-and-the-deployment-platform-is-aws-lambda)
  - [5. We are using CLI in a build system from a provider for which we do not have a working pre-compiled binary](#5-we-are-using-cli-in-a-build-system-from-a-provider-for-which-we-do-not-have-a-working-pre-compiled-binary)
- [Configuration](#configuration)
  - [1. Both `binaryTargets` and `pinnedBinaryTarget` are not provided.](#1-both-binarytargets-and-pinnedbinarytarget-are-not-provided)
  - [2. Field `binaryTargets` provided with multiple values and `pinnedBinaryTarget` is not provided.](#2-field-binarytargets-provided-with-multiple-values-and-pinnedbinarytarget-is-not-provided)
  - [3. Field `binaryTargets` provided with multiple values and `pinnedBinaryTarget` is also provided.](#3-field-binarytargets-provided-with-multiple-values-and-pinnedbinarytarget-is-also-provided)
- [Binary Resolution Error Handling](#binary-resolution-error-handling)
- [Binary Naming Convention](#binary-naming-convention)
- [Runtime Binary Resolution](#runtime-binary-resolution)
- [Pre-built Binary Targets](#pre-built-binary-targets)
  - [URL Scheme](#url-scheme)
  - [Common Cloud Platforms TK Merge with table!](#common-cloud-platforms-tk-merge-with-table)
    - [Tier 1](#tier-1)
    - [Tier 2](#tier-2)
- [Binary Process Management](#binary-process-management)
  - [Connect](#connect)
    - [Find Free Port](#find-free-port)
    - [Binary Spawn](#binary-spawn)
    - [Waiting for the Binary to be Ready](#waiting-for-the-binary-to-be-ready)
    - [Error Handling](#error-handling)
  - [Disconnect](#disconnect)
- [Unresolved questions](#unresolved-questions)

<!-- tocstop -->

# Motivation

## Architecture

![Architecture of how tools like Photon use the Prisma binaries via the Prisma SDK](https://figma-image-proxy.prisma.now.sh/?id=15:1&file=syRJTHIabeqK69mKHBwSlP)

Binaries are the artifacts generated by compiling the Prisma's core (written in Rust). The following binaries are generated:

### Prisma Query Engine Binary

Prisma query engine binary has the following use cases:

A generator like [`Photon`](https://photonjs.prisma.io)

- Uses this binary to run queries against a data source (at runtime of generated code).
- Binary is downloaded when Photon is generated.

Prisma CLI

- Generation uses this binary to fetch internal schema representation (at the time of running `generate` CLI command).
- Binary is downloaded when the CLI is installed.

### Prisma Migration Engine Binary

Prisma migration engine binary has the following use cases:

A generator like `prisma-test-utils`

- Uses this binary to perform migrations (at runtime of generated code)
- Binary is downloaded when `prisma-test-utils` is generated.

Prisma CLI

- Lift commands use the binary to perform migrations or calculate pending migrations (at the time of running various `lift` commands like `up`, `save` etc).
- Binary is downloaded when the CLI is installed.

### Utility Binaries

#### Prisma Format Binary

VSCode Prisma extension uses this binary for providing code formatting features.

## Requirements TK Rethink header

Binaries (query engine binary and migration engine binary) are at the core of Photon, Lift and Prisma CLI via the Prisma SDK. They are, however compiled for a specific platform, that leads to the following requirements:

- Minimal configuration, simple mental model.
- Possibility of a deterministic binary resolution both locally and production setup.
- Easy setup of development and deployment workflows.

## Use Cases

See examples TK Make link

# Binary Files TK Rethink name

## Pre-built Binary Targets TK Add ubuntu

|        **Build**        | **Known Platforms** |                                                            **Query Engine**                                                            | **Migration Engine**                                                                                                                                  | **Prisma Format**                                                                                                           |
| :---------------------: | :-----------------: | :------------------------------------------------------------------------------------------------------------------------------------: | ----------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
|         darwin          | (Local development) |      [prisma-query-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/darwin/prisma-query-engine.gz)      | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/darwin/prisma-migration-engine.gz)                  | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/darwin/prisma-fmt.gz)                  |
|         windows         | (Local development) |         [prisma-query-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/windows/prisma-query-engine.gz)         | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/windows/prisma-migration-engine.gz)                 | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/windows/prisma-fmt.gz)                 |
| linux-glibc-libssl1.0.1 | Lambda Node 8, ZEIT | [prisma-query-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.0.1/prisma-query-engine.gz) | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.0.1/prisma-migration-engine.gz) | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.0.1/prisma-fmt.gz) |
| linux-glibc-libssl1.0.2 |  Lambda (Node 10)   | [prisma-query-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.0.2/prisma-query-engine.gz) | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.0.2/prisma-migration-engine.gz) | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.0.2/prisma-fmt.gz) |
| linux-glibc-libssl1.1.0 |          ?          | [prisma-query-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.1.0/prisma-query-engine.gz) | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.1.0/prisma-migration-engine.gz) | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.1.0/prisma-fmt.gz) |
| linux-glibc-libssl1.1.1 |          ?          | [prisma-query-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.1.1/prisma-query-engine.gz) | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.1.1/prisma-migration-engine.gz) | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-glibc-libssl1.1.1/prisma-fmt.gz) |
| linux-musl-libssl1.0.1  |       Alpine        | [prisma-query-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.0.1/prisma-query-engine.gz)  | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.0.1/prisma-migration-engine.gz)  | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.0.1/prisma-fmt.gz)  |
| linux-musl-libssl1.0.2  |       Alpine        | [prisma-query-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.0.2/prisma-query-engine.gz)  | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.0.2/prisma-migration-engine.gz)  | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.0.2/prisma-fmt.gz)  |
| linux-musl-libssl1.1.0  |       Alpine        | [prisma-query-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.1.0/prisma-query-engine.gz)  | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.1.0/prisma-migration-engine.gz)  | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.1.0/prisma-fmt.gz)  |
| linux-musl-libssl1.1.1  |       Alpine        | [prisma-query-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.1.1/prisma-query-engine.gz)  | [prisma-migration-engine-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.1.1/prisma-migration-engine.gz)  | [prisma-fmt-\${build}](https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/linux-musl-libssl1.1.1/prisma-fmt.gz)  |

<details><summary>TK Merge this into the table</summary>
<p>
## Common Cloud Platforms TK Merge with table!

### Tier 1

- Lambda (Node 8)
- Lambda (Node 10)
- ZEIT
- Netlify
- Heroku
- Google Cloud Functions
- Azure Functions
- CodeSandbox

### Tier 2

- Cloudflare workers
- Raspberry Pi (ARM)
  </p>
  </details>

### URL Scheme

To download the binary, replace `${package}` with a package (e.g. `darwin`) and `${name}` with the name of the binary above (e.g. `query-engine`):

- https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/${package}/${name}
- E.g. https://s3-eu-west-1.amazonaws.com/prisma-native/alpha/latest/darwin/migration-engine

From photon's perspective, we'll download the binaries to `./node_modules/@generated/photon/${package}`.

## Naming Convention

All downloaded binaries must follow the naming convention outlined by the [Table of Binaries](#table-of-binaries). TK Fix the link

This includes both binaries downloaded for a generator and downloaded for CLI commands.

## Custom Binary

In case a binary for your platform is not listed in the [Pre-built Binary Targets](#TK-Add-link). Please follow this section of the docs to build a custom binary. TK Link docs

# Binary Protocols

## Data Protocol

### Prisma Query Engine Binary

Prisma query engine binary uses GraphQL over HTTP.

### Prisma Migration Engine Binary

Prisma migration engine binary uses JSON RPC over HTTP.

## Process management

### Prisma Query Engine Binary

Prisma SDK provide Photon with `connect`, `disconnect` methods for binary process management. If needed, Photon can lazily connect, when a request is received.

## Connect

`connect` function is where Photon spawns the query engine binary and the following sequence of events happen

#### Find Free Port

Photon finds a free port by binding to port 0 with a light-weight TCP server (using node net -> createServer), this makes the OS allocate a random (albeit,
pseudo serial) port to this server, then this server is closed and `Photon` saves the port in memory.

#### Binary Spawn

Photon then spawns the binary as a child process and provide it the environment variables including the detected port

This port is then provided to the binary as an environment variable and the binary starts an HTTP server on this port.

#### Waiting for the Binary to be Ready

In this workflow, Photon polls the query engine binary's HTTP server for its stats at an interval. This can be optimized further by reducing the interval or relying on a simple TCP protocol.

## Disconnect

Calling the `disconnect` method is where Photon waits for any pending request promise to resolve and then kills the spawned process and the DB connection is
released.

### Prisma Migration Engine Binary

Prisma SDK provides a similar API for migration engine binary management. The actual process management is similar to query engine binary. With the following noted differences:

1. Migration engine binary process is short lived.
2. Migration engine binary uses JSON RPC over HTTP as the data protocol.

TK This would vary one generators!! Add note

## Error Handling

### Prisma Query Engine Binary

Photon throws if the engine ready polling does not yield success after N attempts. There may be several reasons why preparing a process with the required
context might fail, including but not limited to:

| Potential Error                            | Handling Strategy |
| ------------------------------------------ | ----------------- |
| Unable to bind to a free port              | Throw error       |
| Binary is not compatible with the platform | Throw error       |
| Binary fails to acquire a DB connection    | Throw error       |

Error handling has a separate spec [here](https://github.com/prisma/specs/tree/master/errors).

### Prisma Migration Engine Binary

TODO: Fill this section

# Use Case: Prisma CLI

## Configuration

Environment variable to configure the binary for CLI (like `prisma2 lift` or `prisma2 generate`):

| Environment Variable             | Description                                                                               | Behavior                                                       |
| -------------------------------- | ----------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| `PRISMA_MIGRATION_ENGINE_BINARY` | (optional) Overrides the resolution path for migration engine binary for `Lift` commands. | Can be a relative (from CWD) or an absolute path to the binary |
| `PRISMA_QUERY_ENGINE_BINARY`     | (optional) Overrides the resolution path for query engine binary for `generate` command.  | Can be a relative (from CWD) or an absolute path to the binary |

- CLI binaries can only be overridden by a path to a custom compiled or provided binary. It does not alter download behavior, it simply overrides the binary to use path for respective commands.

## Example Scenarios

### 1. We are using CLI in a build system from a provider for which we do not have a working pre-compiled binary

Since overriding CLI binary is an environment variable and these providers might [not always allow](https://github.com/prisma/prisma2/issues/157#issuecomment-520501500) compiling a binary. There will be no workaround such a situation except us making the default downloaded binary for that provider work. We want to support all major providers out of the box and this use case should be rare.

# Use Case: Generators

## Configuration

Fields on the `generator` block to configure the availability of binaries for generators (like Photon, nexus, etc):

| Field                | Description                                                                                                                          | Behavior                                           |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------- |
| `binaryTargets`      | _(optional)_ An array of binaries that are required by the application, string for known binaryTargets and path for custom binaries. | Declarative way to download the required binaries. |
| `pinnedBinaryTarget` | _(optional)_ A string that points to the name of an object in the `binaryTargets` field, usually an environment variable             | Declarative way to choose the runtime binary       |

- Both `binaryTargets` and `pinnedBinaryTarget` fields are optional, **however** when a custom binary is provided the `pinnedBinaryTarget` is required.

- Custom binary path points Photon to use the pathv provided.

- Known binary path downloads a known binary to a OS cache path and copies it to generator path on `generate`.

- Not all generators require all the binaries, the generator spec (it will be linked once it is ready) outlines the generator API that defines which binaries are needed.

Both `binaryTargets` and `pinnedBinaryTarget` fields are optional, scenarios:

### 1. Both `binaryTargets` and `pinnedBinaryTarget` are not provided.

```groovy
generator photon {
    provider = "photonjs"
}
```

We download and use the binary for the current platform.

### 2. Field `binaryTargets` provided with multiple values and `pinnedBinaryTarget` is not provided.

```groovy
generator photon {
    provider = "photonjs"
    binaryTargets = ["native", "linux-glibc-libssl1.0.2"]
}
```

Since we do not pin the platform here using `pinnedBinaryTarget`, we need to resolve the binary at runtime, see [Runtime binary resolution] for more details.

**Error Handling**

For fields on the `generator` block:

- If the pinned binary is not found during the generation, generation should fail.

- If the pinned binary is not found during the generated code's runtime, it should throw.

- If the pinned binary is a known binary but does not work for the current platform, try other known binaries from `binaryTargets`. This would make the use cases work where build machine is different from deploy machine, like in the case of zeit's now.

- If the pinned binary is a custom binary but does not work for the current platform, generated code's runtime should throw.

For environment variables used to override the binary used by the CLI:

- If the environment variable path to a custom binary is not found, the respective generate command should throw.

- If the environment variable path to a custom binary exists but the binary is incompatible with the current platform, the respective generate command should throw.

### 3. Field `binaryTargets` provided with multiple values and `pinnedBinaryTarget` is also provided.

```groovy
generator photon {
    provider = "photonjs"
    binaryTargets = ["native", "linux-glibc-libssl1.0.2"]
    pinnedBinaryTarget = env("PLATFORM") // On local, "native" and in production, "linux-glibc-libssl1.0.2"
}
```

```groovy
generator photon {
    provider = "photonjs"
    binaryTargets = ["native", "linux-glibc-libssl1.0.2"]
    pinnedBinaryTarget = env("PLATFORM") // On local, "native" and in production, "linux-glibc-libssl1.0.2"
}
```

We use the `pinnedBinaryTarget` field to pin one of the downloaded binaries at runtime.

Note: In production setups with a dedicated CI, we can configure binaryTargets to only include the required binaries: `binaryTargets = ["linux-glibc-libssl1.0.2"]`

A configuration like `binaryTargets = ["native", "linux-glibc-libssl1.0.2"]` is only needed when the development machine is also the machine responsible to build
for production but the platform in production is different, like `AWS lambda`, `now`, etc.

## Runtime

In the scenario where platforms field is defined but no pinnedPlatform field is defined, we resolve the binary at runtime by detecting the platform. This can be achieved by generating code similar to this pseudo-code in Photon.

```ts
function detectPlatform(): string { ... }

const binaries = {
  'mac': <path>,
  'lambda': <path>,
}
let binaryPath
if (!config.pinnedPlatform) {
  const inferredPlatform = detectPlatform()
  binaryPath = binaries[inferredPlatform]
} else {
  binaryPath = binaries[config.pinnedPlatform]
}

```

For custom binaries, this pseudo-code will fail but pinnedPlatform can be used to choose the correct binary.

## Example Scenarios

### 1. Development machine is Mac but the deployment platform is AWS lambda.

We can use `binaryTargets` **without** a `pinnedBinaryTarget`. `pinnedBinaryTarget` will be resolved at runtime, see [Runtime binary resolution](#runtime-binary-resolution)
for more details.

```groovy
generator photon {
    provider = "photonjs"
    binaryTargets = ["native", "linux-glibc-libssl1.0.2"]
}
```

### 2. Deterministically choose the binary-based a runtime environment variable

We can use `binaryTargets` **and** `pinnedBinaryTarget`. We set an environment variable

```groovy
generator photon {
    provider = "photonjs"
    binaryTargets = ["native", "linux-glibc-libssl1.0.2"]
    pinnedBinaryTarget = env("PLATFORM") // On local, "native" and in production, "linux-glibc-libssl1.0.2"
}
```

We define the binaryTargets and pin one of the binaryTargets.

### 3. Development machine is Mac but we need a custom binary in production

In `binaryTargets`, we can use a custom path to `./custom-prisma-binary`.

```groovy
generator photon {
    provider = "photonjs"
    binaryTargets = ["native", "./custom-prisma-binary"]
    pinnedBinaryTarget = env("PLATFORM") // On local, "native" and in production, "./custom-prisma-binary"
}
```

### 4. Development machine is a Raspberry Pi and the deployment platform is AWS Lambda

As we do not have precompiled binaries for ARM architecture yet, the user would compile binaries manually for query-engine and migration-engine.

```sh
export PRISMA_MIGRATION_ENGINE_BINARY=<path to compiled migration engine binary>
export PRISMA_QUERY_ENGINE_BINARY=<path to compiled query engine binary>
```

Then `prisma2 lift` and `prisma2 generate` would use the respective compiled binaries.

For development and deployment

```groovy
generator photon {
    provider = "photonjs"
    binaryTargets = ["./custom-query-engine-binary", "linux-glibc-libssl1.0.2"]
    pinnedBinaryTarget = env("PLATFORM") // On local, "./custom-query-engine-binary" and in production, "linux-glibc-libssl1.0.2"
}
```

[Examples for other deployment scenarios](https://github.com/prisma/prisma-examples/tree/prisma2/deployment-platforms)

# Unresolved questions

- [ ] Should we unify different binaries (query engine, migration engine, ...) into one single binary?
- [ ] Some platforms [tally `package.json` with the actual contents of `node_modules`](https://github.com/prisma/photonjs/issues/117), this spec does not address
      that issue.
- [ ] Possible New Dimension: Is libssl built for specific distros? E.g. does libssl1.0.1 built on centos not work for ubuntu? https://github.com/prisma/prisma2/issues/157
